---
layout: post
title: Zero Downtime Deployment - Part 1 - The Server
category: "Zero-Downtime"
tags:

- Blue
- CLI
- Docker
- Envoy
- GitLab
- Green
- Laravel

---
Zero Downtime deployment with Laravel Envoy, GitLab, and Docker.

## The Deployment Server

Obviously, if you are deploying a project, you need a server. If you need one,
feel free to sign up for Digital Ocean with my [affilliate
link](https://m.do.co/c/cc1234dc66bf), and (at the time of this writing),
receive $200 in credit to spend over the next 60 days. For the initial
deployment, you only need a $6/month droplet, so try it for free.

Create a droplet running Ubuntu in a datacenter near you, and create two
users. One user will be your regular user, for your day-to day operations with
`sudo` super powers,and the other is your `deploy` user, whose sole purpose will
be to deploy your projects. My `deploy` user is named `deploy`, so that is
what I'll be using for these posts.

### Server Setup

On your shiny new server, create ssh keys for both
users `ssh-keygen -o -a 100 -t ed25519` and
give them password-less logins: `cat ~/.ssh/id_ed25519.pub >> ~/.
ssh/authorized_keys`.

[Install docker](https://docs.docker.com/engine/install/ubuntu/) and
[docker compose](https://docs.docker.com/compose/install/linux/). Once
installed, add both users to the `docker` group, and make sure both users
are successful by running `docker run hello-world`.

Now that you have the users and a working docker installation, set up
traefik. If traefik is new to you, use your favorite search engine to find a
recent how-to that includes a docker provider.

### Set up deploy area

Using
the [project assumptions](/zero-downtime/zero-downtime-deployment-intro/#project-assumptions)
from the intro, the project is code-named `potato`, and we need persistent
mysql and redis services. This setup will use the same services for both
staging and production. In the future, if it's needed, services can be
separated. Let's get them setup.

Log into the deployment server as the deployment user and create a `~/potato`
directory for the project. Everything will live here. Enter the directory,
and copy the [redis config](https://redis.io/docs/manual/config-file/) into
`~/potato/redis.conf.full` and make changes as needed. Now let's get a mysql
and redis docker images running. Create a file in the same directory, I
called mine `daemons.sh`:

{% raw %}
```bash
#!/usr/bin/bash

NETWORK="potato_common"

# Reduce redis.conf.full
echo '## DO NOT EDIT THIS FILE. EDIT redis.conf.full AND RE-RUN ./daemons.sh' > redis.conf
grep -v '^#' redis.conf.full | sort | uniq >> redis.conf

# Network
DOCKER_NETWORK_ID=$(docker network inspect $NETWORK -f '{{ .Id }}')
if [[ "${DOCKER_NETWORK_ID}" == "" ]];
        then
        docker network create $NETWORK;
fi

# Redis
docker run \
        --name redis-potato \
        -h p_redis \
        -d \
        -v redis_potato:/data \
        -v"$(pwd)/redis.conf:/usr/local/etc/redis/redis.conf" \
        --network $NETWORK \
        --restart=unless-stopped \
        redis:7.0.5-alpine3.16 \
        redis-server /usr/local/etc/redis/redis.conf

# Mysql
docker run \
        --name mysql-potato \
        -h p_mysql \
        -v mysql_potato:/var/lib/mysql \
        --network $NETWORK \
        --restart=unless-stopped \
        -e MYSQL_ROOT_PASSWORD=password \
        -e MYSQL_DATABASE=potato \
        -e MYSQL_USER=potato \
        -e MYSQL_PASSWORD=potato \
        -e MYSQL_INITDB_SKIP_TZINFO=true \
        -d \
        mysql:8.0.31
```
{% endraw %}

The script first strips comments from the `redis.conf.full` file and mounts
it into the redis container. Necessary? No, but is makes searching for
configuration settings quicker while getting it set up. It then looks for
the network and creates it as necessary. Then each service is created.

During testing, I was unable to connect to the servers using the container
names, so that's why there is the extra `-h` hostname flag. Maybe there
is something funky with docker and I needed to modify my connection
string. If I figure it out, and remember, I'll update this post. Change the
mysql environment variables and the container names as needed, and set a fairly
secure password. Mysql will set up a single database with the environment
variables provided.

From here, you have a choice to keep the staging and production data separate.
You can use a database prefix, and insert an environment variable into
laravel's `/config/database.php` in the `connections.mysql.prefix` value.
Alternatively, create a new database in the running container, using the
docker image:

```bash
docker run -it --network potato_common --rm mysql:8.0.31 mysql -hv_potato -uroot -ppassword
```

Create a staging database and give the `'potato'@'%'` user full permissions on
the new database.

### The Deployment Environment

Create a `~/potato/staging` directory and `cd` into it. Assuming you want to
keep logs, views, file-based sessions, and caching stable between deployments,
create a storage directory archive and make sure the `www-user` has write
permissions to the directory:

#### Storage Directories

```bash
mkdir -p storage/framework/cache/data
mkdir -p storage/framework/{views,sessions,testing}
mkdir -p storage/app/public
mkdir -p storage/logs
touch storage/logs/laravel.log
chgrp -R www-data storage  # requires sudo, use your sudo enabled user.
chmod g+w storage  # requires sudo, use your sudo enabled user.
```

In the deployment process, this will be linked from the fresh deployment
directory.

#### Environment File

Now create a staging environment file: `nano env` and use the [default Laravel
environment](https://github.com/platformsh-templates/laravel/blob/master/.env.example)
as a starting point. During the deployment process, this will be copied into
the deployment directory as `.env`, but it doesn't need to be hidden here.

If you have an already existing laravel installation,
you can create an app key: `php artisan key:generate --show`

#### Docker Compose File

Create a `docker-compose.yml` file:

```yaml
version: '3.5'
services:
    staging-webserver:
        image: nginx:1.23.2-alpine
        restart: unless-stopped
        working_dir: /application
        volumes:
            - .:/application:delegated
            - ./phpdocker/nginx/nginx.conf:/etc/nginx/conf.d/default.conf
        extra_hosts:
            - 'host.docker.internal:host-gateway'
        networks:
            - potato
            - web
        labels:
            - traefik.docker.network=web
            - traefik.enable=true
            - traefik.port=80
            - traefik.http.routers.staging-potato.entrypoints=websecure
            - traefik.http.routers.staging-potato.rule=Host(`staging.example.com`)
            - traefik.http.routers.staging-potato.middlewares=httpd-security@file

    php-fpm:
        image: registry.gitlab.com/example/example/php-8.1:latest
        restart: unless-stopped
        working_dir: /application
        volumes:
            - .:/application:delegated
            - ./../storage:/application/storage
        labels:
            - traefik.enable=false
        networks:
            - potato_common
            - potato

networks:
    potato:
        name: ${COMPOSE_PROJECT_NAME}
        driver: bridge
    potato_common:
        external: true
    web:
        external: true
```

Make sure you update the `Host` docker labels to point to your actual domain
name. When we get to the code portion, we will make docker images and push
them to the gitlab registry.

This also uses some magic in the docker file, in that the common network
between the `nginx` and `php-fpm` containers is listed as `potato`, but we
define a name for the network. This allows both Blue and Green deployments
to use the same `docker-compose.yml` file, but set the actual name of the
network from an environment variable (coming soon). Without it, the Green nginx
container would have access to the Blue php container, which doesn't keep the
deployments separate.

Now copy your `~/potato/staging` directory to `~/potato/production` and
update the environment variables.

In the next step, we will get a GitLab repository setup.

1. [Configure the Server](/zero-downtime/2022-10-24-zero-downtime-deployment-1-server/)
2. [Configure GitLab](/zero-downtime/2022-10-25-zero-downtime-deployment-2-gitlab/)
3. [Add Code](/zero-downtime/2022-10-26-zero-downtime-deployment-3-laravel/)
